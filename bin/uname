#!/bin/sh

unset s a n r v m o sep gnu

_version() {
	echo "$0 (coreutils-sh) devel"
	exit 0
}

_help() {
	echo "Usage: $0 [OPTION]..."
	echo "Print certain system information.  With no OPTION, same as -s."
	echo ""
	echo "  -a, --all                print all information, in the following order,"
	echo "                             except omit -p and -i if unknown:"
	echo "  -s, --kernel-name        print the kernel name"
	echo "  -n, --nodename           print the network node hostname"
	echo "  -r, --kernel-release     print the kernel release"
	echo "  -v, --kernel-version     print the kernel version"
	echo "  -m, --machine            print the machine hardware name"
	echo "  -o, --operating-system   print the operating system"
	echo "      --help        display this help and exit"
	echo "      --version     output version information and exit"
	exit 0
}

_error() {
	>&2 echo "$*"
	>&2 echo "Try '$0 --help' for more information."
	exit 1
}

_print_info() {
	read -r i < /proc/sys/kernel/"$1"
	if [ -n "$i" ]; then
		printf '%s%s' "$sep" "$i"
		sep=' '
	else
		exit 1
	fi
}

_gnu_linux() {
	# on both BusyBox and GNU uname, a GNU/Linux or Linux string gets
	# compiled into uname, which gets printed when the --all flag is given
	# This means that if you compile a static uname in a glibc system and
	# then run it in alpine, it will print GNU/Linux which is not correct
	#
	# Instead here we will do a runtime check to see if we are on GNU/Linux
	#
	set -- /usr/bin/ldd /bin/ldd
	for ldd do
		[ -f "$ldd" ] || continue
		while IFS="" read -r line; do
			case "$line" in
				*GNU*)
					gnu=GNU/
					break 2
					;;
			esac
		done < "$ldd"
	done

	printf '%s%s' "$sep" "${gnu}Linux"
	sep=' '
}

_uname() {
	if [ "$a" = 1 ]; then
		_print_info 'ostype'
		_print_info 'hostname'
		_print_info 'osrelease'
		_print_info 'version'
		_print_info 'arch'
		_gnu_linux
	else
		[ -n "$s" ] && _print_info 'ostype'
		[ -n "$n" ] && _print_info 'hostname'
		[ -n "$r" ] && _print_info 'osrelease'
		[ -n "$v" ] && _print_info 'version'
		[ -n "$m" ] && _print_info 'arch'
		[ -n "$o" ] && _gnu_linux
	fi
}

_parse_short_flag() {
	while getopts ":sanrvmo" opt; do
		case "$opt" in
			s) s=1;;
			a) a=1;;
			n) n=1;;
			r) r=1;;
			v) v=1;;
			m) m=1;;
			o) o=1;;
			*) _error "$0: invalid option -- '$1'";;
		esac
	done
}

if [ -z "$1" ]; then
	 _print_info 'ostype'
else
	while :; do case "$1" in
		--)                 shift; break;;
		--help)             _help;;
		--all)              a=1; shift;;
		--kernel-name)      s=1; shift;;
		--nodename)         n=1; shift;;
		--kernel-release)   r=1; shift;;
		--machine)          m=1; shift;;
		--operating-system) o=1; shift;;
		-*)                 _parse_short_flag "$@"; shift;;
		*)                  break;;
		esac
	done
fi

if [ -n "$1" ]; then
	_error "$0: extra operand '$1'"
fi

_uname
echo ""

